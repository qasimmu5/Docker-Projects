Introduction: 
We’ll walk through setting up a local development environment for the application we built in the previous modules. We’ll use Docker to build our images and 
Docker Compose to make everything a whole lot easier.

Run a Database in a Container: 
First, we’ll take a look at running a database in a container and how we use volumes and networking to persist our data and allow our application to talk with the 
database. Then we’ll pull everything together into a Compose file which allows us to setup and run a local development environment with one command. Finally, 
we’ll take a look at connecting a debugger to our application running inside a container.

Instead of downloading MySQL, installing, configuring, and then running the MySQL database as a service, we can use the Docker Official Image for MySQL and 
run it in a container.

Managed Volumes or Bind mounts: 
Before we run MySQL in a container, we’ll create a couple of volumes that Docker can manage to store our persistent (permenant) data and configuration. 
Let’s use the managed volumes feature that Docker provides instead of using bind mounts. 

Volumes are the preferred mechanism for persisting data generated by and used by Docker containers. While bind mounts are dependent on the directory structure and 
OS of the host machine, volumes are completely managed by Docker, so they are independent from the host machine. Volumes have several advantages over bind mounts:

- Volumes are easier to back up or migrate than bind mounts.
- You can manage volumes using Docker CLI commands or the Docker API.
- Volumes work on both Linux and Windows containers.
- Volumes can be more safely shared among multiple containers.
- Volume drivers let you store volumes on remote hosts or cloud providers, to encrypt the contents of volumes, or to add other functionality.
- New volumes can have their content pre-populated by a container.
- Volumes on Docker Desktop have much higher performance than bind mounts from Mac and Windows hosts.
In addition, volumes are often a better choice than persisting data in a container’s writable layer, because a volume does not increase the size of the containers 
using it, and the volume’s contents exist outside the lifecycle of a given container.

Bind mounts have been around since the early days of Docker. Bind mounts have limited functionality compared to volumes. When you use a bind mount, a file or 
directory on the host machine is mounted into a container. The file or directory is referenced by its absolute path on the host machine. By contrast, when you use 
a volume, a new directory is created within Docker’s storage directory on the host machine, and Docker manages that directory’s contents.

Creating Volumes for our MySQL: 
Let’s create our volumes now. We’ll create one for the data and one for configuration of MySQL.

docker volume create mysql
docker volume create mysql_config

"docker volume ls" will show you the list of volumes.

Now we’ll create a network that our application and database will use to talk to each other. The network is called a user-defined bridge network and gives us a 
nice DNS lookup service which we can use when creating our connection string.

What is a Bridge Network and a User Defined Bridge: 
In terms of networking, a bridge network is a Link Layer device which forwards traffic between network segments. Bridge network comes under the 2nd layer 
in the OSI model called the data link layer. It inspects incoming traffic and decide whether to forward it or filter it. Each incoming Ethernet frame is inspected 
for destination MAC address. If the bridge determines that the destination host is on another segment of the network, it forwards the frame to that segment. So 
basically it can connect 2 segaments by a bridge. Bridge can be a hardware device or a software device running within a host machine’s kernel.

In terms of Docker, a bridge network uses a software bridge which allows containers connected to the same bridge network to communicate, while providing isolation
from containers which are not connected to that bridge network. The Docker bridge driver automatically installs rules in the host machine so that containers on 
different bridge networks cannot communicate directly with each other.

Bridge networks applys to containers running on the same Docker daemon host, so basically both the containers must be running on the same host machine. For 
communication among containers running on different Docker daemon hosts, you can either manage routing at the OS level, or you can use an overlay network.

When you start Docker, a default bridge network (also called bridge) is created automatically, and newly-started containers connect to it unless otherwise 
specified. You can also create user-defined custom bridge networks. User-defined bridge networks are superior to the default bridge networks. 

Difference between user-defined bridges and the default bridge: 

User-defined bridges provide automatic DNS resolution between containers. DNS (Domain Name Server) resolution is the process of translating IP addresses to domain
names. When a profile is configured to look up all numeric IP addresses, Webtrends makes a call to the network's DNS server to resolve DNS entries. Containers on 
the default bridge network can only access each other by IP addresses, unless you use the --link option, which is considered legacy. On a user-defined bridge network, containers can resolve each other by name or alias.

Imagine an application with a web front-end and a database back-end. If you call your containers web and db, the web container can connect to the db container at 
db, no matter which Docker host the application stack is running on.If you run the same application stack on the default bridge network, you need to manually create links between the containers (using the legacy --link flag). 
These links need to be created in both directions, so you can see this gets complex with more than two containers which need to communicate. Alternatively, you can
manipulate the /etc/hosts files within the containers, but this creates problems that are difficult to debug.

User-defined bridges provide better isolation.

All containers without a --network specified, are attached to the default bridge network. This can be a risk, as unrelated stacks/services/containers are then 
able to communicate. Using a user-defined network provides a scoped network in which only containers attached to that network are able to communicate.

Containers can be attached and detached from user-defined networks on the fly. During a container’s lifetime, you can connect or disconnect it from user-defined 
networks on the fly. To remove a container from the default bridge network, you need to stop the container and recreate it with different network options.

Back to creating a network so our application and database can talk to each other: Type the command to make a user-defined bridge network. 

docker network create mysqlnet

You can "docker network ls" to see the list of networks and will display, the network ID, name of the network, driver and scope. 

Now we can run MySQL in a container and attach to the volumes and network we created above. In this case our volumes are mysql, mysql_config and our network is 
mysqlnet. Docker pulls the mysql image from Hub and runs it for you locally. In the following command, option -v is for starting the container with volumes.

docker run --rm -d -v mysql:/var/lib/mysql \
  -v mysql_config:/etc/mysql -p 3306:3306 \
  --network mysqlnet \
  --name mysqldb \
  -e MYSQL_ROOT_PASSWORD=p@ssw0rd1 \
  mysql

Lets go through the information provided above. 
The --rm flag is there to tell the Docker Daemon to clean up the container and remove the file system after the container exits. This helps you save disk space 
after running short-lived containers like this one, that we only started to print "Hello, World!".

-d flag is the detached mode where the container is running in the backend and you still have your host terminal or CLI access. 

-v flag is used to attach the volumes we created to this container. 
-v or --volume: Consists of three fields, separated by colon characters (:). The fields must be in the correct order, and the meaning of each field is not 
immediately obvious. In the case of named volumes, the first field is the name of the volume, and is unique on a given host machine. For anonymous volumes, 
the first field is omitted.The second field is the path where the file or directory are mounted in the container we created.
The third field is optional, and is a comma-separated list of options, such as ro

"\" is to represent a new line

-p flag is the port. So we are connecting the host port to the local port. 

--network flag is used to attach the user-defined bridge we created to the container. 

--name flag is giving this container a name. 

-e flag is the environment variable flag. In this case the value to which we are giving the variable MYSQL_ROOT_PASSWORD is the password to conntect to the 
database. 

lastly mysql is the image which is being imported from Docker Hub. 

Note: When I do run that docker command I get an error responding: 
Unable to find image 'mysql:latest' locally
latest: Pulling from library/mysql
docker: no matching manifest for linux/arm64/v8 in the manifest list entries.

This is due to Mac M1 processor. So to fix this issue, you have to pull the mysql image first then run the docker run command. So type the following command:
docker pull --platform linux/x86_64 mysql

Now you can run the following docker run command: 

docker run --rm -d -v mysql:/var/lib/mysql \
  -v mysql_config:/etc/mysql -p 3306:3306 \
  --network mysqlnet \
  --name mysqldb \
  -e MYSQL_ROOT_PASSWORD=p@ssw0rd1 \
  mysql
  
If you do docker ps. You will see your mysql container is running. 
Now, let’s make sure that our MySQL database is running and that we can connect to it. Connect to the running MySQL database inside the container using the 
following command and enter “p@ssw0rd1” when prompted for the password:

docker exec -ti mysqldb mysql -u root -p

docker exec -> The docker exec command runs a new command in a running container. The command started using docker exec only runs while the container's primary 
process ( PID 1 ) is running, and it is not restarted if the container is restarted. COMMAND will run in the default directory of the container. Basically
running the CLI in the container. 

mysqldb -> is the name of the container and mysql is the image name. 

"mysql -u root -p" means you are trying to connect to MySQL shell as a root user, so -u root means going to connect with a username root, and -p means we will
enter usernames password. So right after -p you would include the password. In this case our password would be p@ssw0rd1 because when running the docker run 
command we speecified the environment variable -e MYSQL_ROOT_PASSWORD=p@ssw0rd1. 

Successful login -> You will see you are in MySQl shell command on the terminal display! 

Connect the Application to the Database: 
In the above command, we logged in to the MySQL database by passing the ‘mysql’ command to the mysqldb container, so we logged in by mysql -u root -p. Press 
CTRL-D to exit the MySQL interactive terminal.

Okay, now that we have a running MySQL, let’s update the app.py to use MySQL as a datastore and connect to it. Let’s also add some routes to our server. One for 
fetching records and one for inserting records. In a database, a record (sometimes called a row) is a group of fields within a table that are relevant to a 
specific entity.
Code for app.py below: 

import mysql.connector # used to connect to MySQL database
import json 
"""
It is the string version that can be read or written to a file. ... Use the import function to import the JSON module. 
import json. The JSON module is mainly used to convert the python dictionary above into a JSON string that can be written 
into a file.

"""
from flask import Flask

app = Flask(__name__)

""" Every web framework begins with the concept of serving content at a given URL. Routes refer to URL patterns of an app 
(such as myapp.com/home or myapp.com/about). Views refer to the content to be served at these URLs, whether that be a 
webpage, an API response, etc. Also just notice after the route decorator you cant put any comments but a function 
or a class """

@app.route('/') 
def hello_world():
    return 'Hello, Docker!'

@app.route('/widgets')
def get_widgets():
  mydb = mysql.connector.connect( #connecting to the database
    host="mysqldb", # this is the containers name we gave
    user="root", # logging in as a root user
    password="p@ssw0rd1", # the password we set
    database="inventory" # creating a new database called inventory
  )
  """ The MySQLCursor of mysql-connector-python (and similar libraries) is used to execute statements to communicate 
     with the MySQL database. Using the methods of it you can execute SQL statements, fetch data from the result 
     sets, call procedures.
    """
  cursor = mydb.cursor()
  
  """ This method accepts a MySQL query as a parameter and executes the given query.
  The SELECT statement is used to select data from a database. The data returned is stored in a result table, 
  called the result-set. SELECT Syntax: 
  SELECT column1, column2, ...
  FROM table_name;
  Here, column1, column2, ... are the field names of the table you want to select data from. If you want to 
  select all the fields available in the table, use the following syntax:
  SELECT * FROM table_name;
  """
  
  cursor.execute("SELECT * FROM widgets")
  row_headers=[x[0] for x in cursor.description] 
  #this will extract row headers, will get only column names from cursor description 

  """fetchall() Method. Syntax: rows = cursor. fetchall() The method fetches all (or all remaining) rows 
  of a query result set and returns a list of tuples. If no more rows are available, it returns an empty list."""

  results = cursor.fetchall()
  json_data=[] # creates an empty list 

  for result in results: # going  through a loop through each rows 
    json_data.append(dict(zip(row_headers,result))) #adding the value in each row and columns to the list json_data

  cursor.close() #closing the connection to the database server. 
  
  """The dumps() is used when the objects are required to be in string format and is used for parsing, 
  printing, etc, """
  return json.dumps(json_data)

@app.route('/initdb')
def db_init():
  mydb = mysql.connector.connect(
    host="mysqldb",
    user="root",
    password="p@ssw0rd1"
  )
  cursor = mydb.cursor()
  """ 
  To remove an existing database from a SQL Server instance, you use the DROP DATABASE statement.
  The DROP DATABASE statement allows you to delete one or more databases with the following syntax:
  DROP DATABASE  [ IF EXISTS ]
    database_name 
    [,database_name2,...];
  """
 
  cursor.execute("DROP DATABASE IF EXISTS inventory")

  """
  The CREATE DATABASE statement is used to create a new SQL database.
  """
  cursor.execute("CREATE DATABASE inventory")
  
  cursor.close()

  mydb = mysql.connector.connect(
    host="mysqldb",
    user="root",
    password="p@ssw0rd1",
    database="inventory"
  )
  cursor = mydb.cursor()

  cursor.execute("DROP TABLE IF EXISTS widgets")

  """
  The CREATE TABLE statement is used to create a new table in a database.
  CREATE TABLE table_name (
    column1 datatype,
    column2 datatype,
    column3 datatype,
   ....
);
  The column parameters specify the names of the columns of the table.
  The datatype parameter specifies the type of data the column can hold (e.g. varchar, integer, date, etc.)
  Example: 
  The PersonID column is of type int and will hold an integer.
  The LastName, FirstName, Address, and City columns are of type varchar and will hold characters, and the maximum length for these fields is 255 characters.
  
  """
  cursor.execute("CREATE TABLE widgets (name VARCHAR(255), description VARCHAR(255))")
  cursor.close()

  return 'init database'

if __name__ == "__main__":
  app.run(host ='0.0.0.0')

Code for app.py finished:

We’ve added the MySQL module and updated the code to connect to the database server, created a database and table. We also created a couple of routes to 
save widgets and fetch widgets. We now need to rebuild our image so it contains our changes.
First, let’s add the mysql-connector-python module to our application using pip.

pip3 install mysql-connector-python
pip3 freeze | grep mysql-connector-python >> requirements.txt

Now we can build our image.

docker build --tag python-docker-dev .

Now, let’s add the container to the database network or the user defined bridge network we created and then run our container. This allows us to access the 
database by its container name.

docker run \
  --rm -d \
  --network mysqlnet \
  --name rest-server \
  -p 3000:5000 \
  python-docker-dev

In this, you can see -d flag is detached mode so the container is running in the background. --network mysqlnet is where our database server container is
connected to. --name rest-server is the name of the container. -p we gave 3000 port to be used to talk from the container to the outside the container. 
python-docker-dev is our image we created. 

Let’s test that our application is connected to the database and is able to add a note.
curl http://localhost:3000/initdb
curl http://localhost:3000/widgets

curl http://192.168.2.153:3000/initdb
curl http://192.168.2.153:3000/widgets

You should receive the following JSON back from our service.

[]

Use Compose to Develop locally: 

In this section, we’ll create a Compose file to start our python-docker and the MySQL database using a single command. 
Compose is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application’s services. 
Then, with a single command, you create and start all the services (containers) from your configuration. Compose works in all environments: production, staging, 
development, testing, as well as CI workflows.

We’ll also set up the Compose file to start the python-docker-dev application in debug mode so that we can connect a debugger to the running process.
Open the python-docker directory in your IDE or a text editor and create a new file named docker-compose.dev.yml. Copy and paste the following commands into 
the file.

version: '3.8'

services:
 web:
  build:
   context: .
  ports:
  - 5000:5000
  volumes:
  - ./:/app

 mysqldb:
  image: mysql
  ports:
  - 3306:3306
  environment:
  - MYSQL_ROOT_PASSWORD=p@ssw0rd1
  volumes:
  - mysql:/var/lib/mysql
  - mysql_config:/etc/mysql

volumes:
  mysql:
  mysql_config:
  
This Compose file is super convenient as we do not have to type all the parameters to pass to the docker run command. We can declaratively do that using a 
Compose file. We expose port 3000 so that we can reach the dev web server inside the container. We also map our local source code into the running container to 
make changes in our text editor and have those changes picked up in the container.
Another really cool feature of using a Compose file is that we have service resolution set up to use the service names. Therefore, we are now able to 
use “mysqldb” in our connection string. The reason we use “mysqldb” is because that is what we’ve named our MySQL service as in the Compose file.
Now, to start our application and to confirm that it is running properly, run the following command:

docker-compose -f docker-compose.dev.yml up --build

We pass the --build flag so Docker will compile our image and then start the containers.
Now let’s test our API endpoint. Open a new terminal then make a GET request to the server using the curl commands:

 curl http://localhost:5000/initdb
 curl http://localhost:5000/widgets
 
 curl http://192.168.2.153:3000/initdb
 curl http://192.168.2.153:3000/widgets

You should receive the following response:

[]

So what this compose file did was started our application server container which contains our app.py and also it started the mysql database server in a container,
and connected both of them. It also crearted 2 volumes. 



